// The formulas are inspired by simple-inversion amoslu-photo

DEFINE_UI_PARAMS(DminR, DminR, DCTLUI_SLIDER_FLOAT, 0.90f, 0.0f, 3.0f, 0.001f)
DEFINE_UI_PARAMS(DminG, DminG, DCTLUI_SLIDER_FLOAT, 0.90f, 0.0f, 3.0f, 0.001f)
DEFINE_UI_PARAMS(DminB, DminB, DCTLUI_SLIDER_FLOAT, 0.90f, 0.0f, 3.0f, 0.001f)

DEFINE_UI_PARAMS(DmaxR, DmaxR, DCTLUI_SLIDER_FLOAT, 0.10f, 0.0f, 2.0f, 0.001f)
DEFINE_UI_PARAMS(DmaxG, DmaxG, DCTLUI_SLIDER_FLOAT, 0.10f, 0.0f, 2.0f, 0.001f)
DEFINE_UI_PARAMS(DmaxB, DmaxB, DCTLUI_SLIDER_FLOAT, 0.10f, 0.0f, 2.0f, 0.001f)

DEFINE_UI_PARAMS(Gamma, BaseCurveGamma, DCTLUI_SLIDER_FLOAT, 1.00f, 0.00f, 6.00f, 0.01f)
DEFINE_UI_PARAMS(Exposure, Exposure, DCTLUI_SLIDER_FLOAT, 0.00f, -10.00f, 10.00f, 0.01f)

__DEVICE__ float _safe_div(float num, float den, float fb) {               
    return (fabsf(den) < 1e-12f) ? fb : (num / den);
}
__DEVICE__ float _safe_log10(float x) {     
    return log10f(x <= 0.0f ? 1e-12f : x);
}

__DEVICE__ float _base_curve(float x, float gamma) {
    if (gamma <= 0.0f) return x;
    float denom = powf(10.0f, gamma) - 1.0f;
    float num   = powf(10.0f, x * gamma) - 1.0f;
    return _safe_div(num, denom, x);
}

__DEVICE__ float _invert_chan(float in_c, float dmin_c, float dmax_c, float gamma, float Exposure) {
    float den = _safe_log10(dmin_c / dmax_c);
    float num = _safe_log10(dmin_c / in_c);
    float x   = _safe_div(num, den, 0.0f);  

    float y = _base_curve(x, gamma);  
    y *= powf(2.0f, Exposure);    
    return y;                                       
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float r = _invert_chan(p_R, DminR, DmaxR, Gamma, Exposure);
    float g = _invert_chan(p_G, DminG, DmaxG, Gamma, Exposure);
    float b = _invert_chan(p_B, DminB, DmaxB, Gamma, Exposure);
    return make_float3(r, g, b);
}
